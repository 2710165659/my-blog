
# 排序

## 插入排序

```c++
/* 插入排序 */
void insertionSort(vector<int> &nums) {
    // 外循环：已排序元素数量为 1, 2, ..., n
    for (int i = 1; i < nums.size(); i++) {
        int base = nums[i], j = i - 1;
        // 内循环：将 base 插入到已排序部分的正确位置
        while (j >= 0 && nums[j] > base) {
            nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位
            j--;
        }
        nums[j + 1] = base; // 将 base 赋值到正确位置
    }
}
```

## 选择排序

```c++
/* 选择排序 */
void selectionSort(vector<int> &nums) {
    int n = nums.size();
    // 外循环：未排序区间为 [i, n-1]
    for (int i = 0; i < n - 1; i++) {
        // 内循环：找到未排序区间内的最小元素
        int k = i;
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[k])
                k = j; // 记录最小元素的索引
        }
        // 将该最小元素与未排序区间的首个元素交换
        swap(nums[i], nums[k]);
    }
}
```

## 冒泡排序

```c++
/* 冒泡排序 */
void bubbleSort(vector<int> &nums) {
    // 外循环：未排序区间为 [0, i]
    for (int i = nums.size() - 1; i > 0; i--) {
        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
        for (int j = 0; j < i; j++) {
            if (nums[j] > nums[j + 1]) {
                // 交换 nums[j] 与 nums[j + 1]
                // 这里使用了 std::swap() 函数
                swap(nums[j], nums[j + 1]);
            }
        }
    }
}
```

## 快速排序

```c++
/* 元素交换 */
void swap(vector<int>& nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
/* 哨兵划分 */
int partition(vector<int>& nums, int left, int right) {
    // 以 nums[left] 作为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= nums[left])
            j--; // 从右向左找首个小于基准数的元素
        while (i < j && nums[i] <= nums[left])
            i++;          // 从左向右找首个大于基准数的元素
        swap(nums, i, j); // 交换这两个元素
    }
    swap(nums, i, left); // 将基准数交换至两子数组的分界线
    return i;            // 返回基准数的索引
}
/* 快速排序 */
void quickSort(vector<int>& nums, int left, int right) {
    // 子数组长度为 1 时终止递归
    if (left >= right)
        return;
    // 哨兵划分
    int pivot = partition(nums, left, right);
    // 递归左子数组、右子数组
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}
```

# 前缀和与差分

## 介绍

输入一个长度为 n 的整数序列。 接下来再输入 m 个询问，每个询问输入一对 l,r 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和

Tip:  在构造sum数组时，有一个小技巧，就是初始化将 _**sum[0]=0**_，从下标为1开始记录，**sum[i]表示前i个数的和**

<font color="#FF0000">注意:开long long</font>

```c++
#include <iostream>
using namespace std;

int  main() {
	int n;
	cin >> n;
	int* nums = new int[n + 1] ();
	int* sum = new int[n + 1] (); //sum[n]表示前n个数的和
	for (int i = 1; i <= n; i++) {
		cin >> nums[i];
		sum[i] = sum[i - 1] + nums[i];
	}
	int m;
	cin >> m;
	while (m--) {
		int l, r;
		cin >> l >> r;
		cout << sum[r] - sum[l-1] << endl;
	}
}
```

## 例题P3397

在$n×n$ $的格子上有$ $m$个地毯。
给出这些地毯的信息，问每个点被多少个地毯覆盖。

**输入格式**
第一行，两个正整数$n,m$。意义如题所述。
接下来 m 行，每行两个坐标$(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。

==地毯不需要开long long==

### 暴力

```c++
int ans[1010][1010] = {0};
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		for (int i = x1; i <= x2; i++) {
			for (int j = y1; j <= y2; j++) {
				ans[i][j]++;
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cout << ans[i][j] << " ";
		}
		cout << '\n';
	}
}
```

### 每一行求前缀和再差分

```c++
int ans[1010][1010] = {0};
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		for (int i = x1; i <= x2; i++) {
			ans[i][y1]++;
			ans[i][y2 + 1]--;					//每一行地毯结束的右边 y2+1 处开始减
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			ans[i][j] += ans[i][j - 1];
			cout << ans[i][j] << " ";
		}
		cout << '\n';
	}
}
```

### 在行差分的基础上对列差分

```c++
int ans[1010][1010] = {0};
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		ans[x1][y1]++;
		ans[x2 + 1][y1]--;					//地毯结束范围外减一
		ans[x1][y2 + 1]--;					//地毯结束范围外减一
        ans[x2 + 1][y2 + 1]++;				//右和下都减会多减一，需要加回来
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			ans[i][j] += ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1];
			cout << ans[i][j] << " ";
		}
		cout << '\n';
	}
}
```

# 贪心

==贪心==，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。

_不会用来骗分_

# 二分查找

## 概述

**二分答案：** 对答案进行二分,用一个check函数判断是否通过，如果可行，尝试扩大答案l=mid+1不可行r=mid-1

​					<u>特别注意</u>,二分答案需要对边界进行特殊判断，因为二分到边界后不会check边界而是直接退出循环

==要求:有序序列==

==开闭区间==与left,right的初始值有关

- [left,right]  left=0,right=length-1
- (left,right]  left=-1,right=length-1
- [left,right)  left=0,right=length

==有重复元素时返回下标==与找到目标元素后边界变动有关:

- 边界左移(返回最近目标元素下标)   right=mid-1
- 边界右移(返回最远目标元素下标)   left=mid+1

==未找到元素返回值==与返回元素有关

- 返回left
- 返回插入位置 target <= nums[mid]
- 等于后移动r返回是左侧,等于后移动l返回是右侧

## 无重复元素

**C++中为了防止left+right超过int最大值溢出:  mid = left + (right - left) / 2**

```python
def lower_bound(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1  # 闭区间 [left, right]
    while left <= right:  # 区间不为空
     # 循环不变量：
     # nums[left-1] < target
     # nums[right+1] >= target
     mid = (left + right) // 2
     if nums[mid] < target:
         left = mid + 1  # 范围缩小到 [mid+1, right]
     else:
         right = mid - 1  # 范围缩小到 [left, mid-1]
    return left  # 或者 right+1

```

```c++
public void binarySearch(int[] nums,int target){
    int left = 0;
    int right = a.length - 1;
    while(left <= right){
        int mid = (left + right) / 2;
        if(target < nums[mid]){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else{
            return mid;
        }
    }
    retun -1;
}
```

## 有重复元素

- 开闭区间同上
- 返回最左边元素下标  ==right = mid - 1;==
- 返回最右边元素下标 ==left= mid + 1;==

```c++
public int binarySearch(int[] nums,int target){
    int left = 0;
    int right = nums.length - 1;

    int condition = -1;

    while(left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] < target){
            left = mid + 1;
        }else if(target < nums[mid]){
            right = mid - 1;
        }else{
            condition = mid;
        // 如果找到了目标元素，继续向左查找(返回左侧下标)
            right = mid - 1;
         // 如果找到了目标元素，继续向右查找(返回右侧下标)
        //	left= mid + 1;
     	}
    }
    return condition;
}
```

## 未找到元素时返回插入位置

1. 如果目标元素存在，返回的是最左的索引（包含数组中有重复元素的情况）。
2. 如果目标元素不存在，返回的是它插入的位置。

```c++
public int binarySearch(int[] nums,int target){
	int left = 0;
 int right = nums.length - 1;
 while(left <= right){
     int mid = (left + right) >>> 1;
     if(target <= nums[mid]){	// 等于后移动r返回是左侧,等于后移动l返回是右侧
         right = mid - 1;
     }else{
         left = mid + 1;
     }
 }
 return left;
}
```

```c++
// 二分查找（返回值<=target的最右索引）  若目标元素最大，nums.length-1
public int binarySearch(int[] nums,int target){
	int left = 0;
   int right = nums.length - 1;
   while(left <= right){
       int mid = (left + right) >>> 1;
       if(target < nums[mid]){
           right = mid - 1;
       }else{
           left = mid + 1;
       }
   }
   return left - 1;
}
```

## 二分答案

答案在一个固定区间内，并且是单调的，可以进行优化O(n)到O(logn)

```c++
int l=1,r=d,mid,ans;//l r为答案左右边界
    while (l<=r){//二分的格式
        mid=(l+r)/2;
        if (check(mid)){
            ans=mid;
            l=mid+1;
        } 
        else r=mid-1;
    }
    cout << ans;
```

# 双指针

**双指针（Two Pointers）**：指的是在遍历元素的过程中，不是使用单个指针进行访问，而是使用两个指针进行访问，从而达到相应的目的。如果两个指针方向相反，则称为==「对撞指针」==。如果两个指针方向相同，则称为==「快慢指针」==。如果两个指针分别属于不同的数组 / 链表，则称为==「分离双指针」==。

## 对撞指针

对撞指针一般用来解决**有序数组**或者**字符串**问题。

==例题:==[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

- 查找有序数组中满足某些约束条件的一组元素问题：比如二分查找、数字之和等问题。
- 字符串反转问题：反转字符串、回文数、颠倒二进制等问题。

```python
left, right = 0, len(nums) - 1

while left < right:
    if 满足要求的特殊条件:
        return 符合条件的值 
    elif 一定条件 1:
        left += 1
    elif 一定条件 2:
        right -= 1

return 没找到 或 找到对应值
```

## 快慢指针

快慢指针一般用于处理**数组中的移动、删除元素问题，或者链表中的判断是否有环、长度**问题。

==例题:==[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```python
 slow = 0
 fast = 1
 while 没有遍历完：
     if 满足要求的特殊条件:
         slow += 1
     fast += 1
 return 合适的值
```

## 分离双指针

分离双指针一般用于处理**有序数组合并，求交集、并集**问题。

==例题:==[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

```python
 left_1 = 0
 left_2 = 0
 
 while left_1 < len(nums1) and left_2 < len(nums2):
     if 一定条件 1:
         left_1 += 1
         left_2 += 2
     elif 一定条件 2:
         left_1 += 1
     elif 一定条件 3:
         left_2 += 1
```

# 离散化

**离散化**：把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。

离散化常与差分、前缀和、数组数组、线段树结合考查。

**两个实现方式：**

1. **手写离散化**

   例如：对于序列 [105，35，35，79，-7]，排序并去重后变为 [-7，35，79，105]，由此就得到了对应关系 -7->1, 35->2, 79->3, 105->4。

   基本的步骤可以分为：

   1、用一个辅助的数组把你要离散的所有数据存下来。

   2、排序，排序是为了后面的二分。

   3、去重，因为我们要保证相同的元素离散化后数字相同。

   4、索引，再用二分把离散化后的数字放回原数组。

2. **map映射**

   （由于不需要排序和去重等操作，会比第一种好写，且代码量会少很多）：可以用 map（每次在map中查询一下这个值是否存在，如果存在则返回对应的值，否则对应另一个值）或 hash表（即unordered_map或手写hash表，运用方式和map相同）。

==例题:==[1952. 金发姑娘和 N 头牛](https://www.acwing.com/problem/content/description/1954/)   离散化+区间和

```c++
//手写离散化
 
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // +1:映射到1, 2, ...n（不加的话就是0~n-1）
}
```

# 快速幂

**核心思想：每一次运算都把指数折半，底数变其平方**

cmath里的pow函数用的就是快速幂

例: 求n的m次方:

```c++
long long quick_pow(int base, int pow) {
	long long result=1;
	while (pow > 0) {
		if (pow % 2 == 1) result *= base;
		base *= base;
		pow /= 2;
	}
	return result;
}
```

# 求模常用公式

**四则运算**

- (a + b) % p = (a % p + b % p) % p
- (a - b) % p = (a % p - b % p ) % p
- (a * b) % p = (a % p * b % p) % p
- a ^ b % p = ((a % p)^b) % p

**重要定理**

同余定理 a≡b (% p)    a%p==b%p

- 若a≡b (% p)，则对于任意的c，都有(a + c)/ ≡ (b + c) (%p)；
- 若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)；
- 若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)，(a * c) ≡ (b * d) (%p)；

# gcd/lcm

gcd:最大公约数 欧几里得算法(辗转相除法)

```c++
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

```c++
//位运算  未定义行为
int gcd(int a,int b){
    while(b^=a^=b^=a%=b);
    return a;
}
```

lcm:最小公倍数

```c++
int lcm(int a,int b){
    return a/gcd(a,b)*b;
}
```

# 高精度计算

## 高精度加法

```c++
string add(string s1, string s2) {
	if (s1.size() < s2.size()) swap(s1, s2);
	int n = s1.size()+1;//n为运算后的最大位数
	//s1为大数
	vector<int> a(n, 0);
	for (int i = s1.size() - 1, j = 0; i >= 0; i--) a[j++] = s1[i] - '0';
	for (int i = s2.size() - 1, j = 0; i >= 0; i--) a[j++] += s2[i] - '0';
	//处理进位
	for (int i = 0; i< n-1; i++) {
		a[i + 1] += a[i] / 10;
		a[i] %= 10;
	}
	//处理溢出0  //相加最大溢出一个0
	while (n > 0 && a[n - 1] == 0) n--;
	if(n==0) return "0";
	//倒序输出
	string result(n,'0');
	for (int i = n-1,j=0; i >= 0; i--) result[j++] = a[i]+'0';
	return result;
}
```

## 高精度减法

```c++
string sub(string s1, string s2) {
	//s1-s2
	string negative;
	if (s1 == s2) return "0";
	if (s1.size() < s2.size() || s1.size() == s2.size() && s1 < s2) {
		swap(s1, s2);
		negative = string(1, '-');
	}
	int n = s1.size();//n为运算后的最大位数
	//s1为大数
	vector<int> a(n, 0);
	for (int i = s1.size() - 1, j = 0; i >= 0; i--) a[j++] = s1[i] - '0';
	for (int i = s2.size() - 1, j = 0; i >= 0; i--) a[j++] -= s2[i] - '0';
	//处理进位
	for (int i = 0; i < n - 1; i++) {
		if (a[i] < 0) {
			a[i + 1]--;
			a[i] += 10;
		}
	}
	//处理溢出0
	while (n > 0 && a[n - 1] == 0) n--;
	if(n==0) return "0";
	//倒序输出
	string result(n, '0');
	for (int i = n - 1, j = 0; i >= 0; i--) result[j++] = a[i] + '0';
	//返回结果+处理负数
	return  negative + result;
}
```

## 高精度乘法

```c++
string multi(string s1, string s2) {
	if (s1.size() < s2.size()) swap(s1, s2);
	int n = s1.size() + s2.size();//n为运算后的最大位数
	//s1为大数
	vector<int> a(n, 0);
	for (int i = s1.size() - 1, p1 = 0; i >= 0; i--, p1++) {
		for (int j = s2.size() - 1, p2 = 0; j >= 0; j--, p2++) {
			a[p1 + p2] += (s1[i] - '0') * (s2[j] - '0');
		}
	}
	//处理进位
	for (int i = 0; i < n-1; i++) {
		a[i + 1] += a[i] / 10;
		a[i] %= 10;
	}
	//处理溢出
	while (n > 0 && a[n - 1] == 0) n--;
	if(n==0) return "0";
	//输出结果
	string result(n, '0');
	for (int i = n - 1, j = 0; i >= 0; i--) result[j++] = a[i]+'0';
	return result;
}
```

## 高精度除低精度

```c++
string devide(const string& s1,int s2){
	string result;
	long long temp=0;
	for(int i=0;i<s1.size();i++){
		temp+=s1[i]-'0';
		result+=(temp/s2)+'0';
		temp%=s2;
		temp*=10;
	}
	
	for(int i=0;i<result.size();i++){
		if(result[i]!='0') return result.substr(i);
	}
	return "0";
}
```

# 全排列

```c++
#include<stdio.h>
void Swap(int&amp; a, int&amp; b)/*交换函数，将a和b的值互换*/
{
	int c = a;
	a = b;
	b = c;
}
void Perm(int* br, int k, int m)/*br代表要进行全排列的数组，k~m代表这个数组中要进行全排列数字的范围*/
{
	if (k == m)
	{
		for (int i = 0; i <= m; ++i)
		{
			printf("%d ", br[i]);
		}
		printf("\n");
	}
	else
	{
		for (int j = k; j <= m; ++j)
		{
			Swap(br[j], br[k]);
			Perm(br, k + 1, m);
			Swap(br[j], br[k]);
		}
	}
}
int main()
{
	int ar[] = { 1,2,3 };
	int n = sizeof(ar) / sizeof(ar[0]);
	Perm(ar, 0, n - 1);
	return 0;
}
```

# STL 常用算法

`#include  <algorithm>`

`using namespace std;`

## 通用算法

| 函数                                  | 时间复杂度   | 参数                                   | 返回值 | 简单说明                                                             |
| ------------------------------------- | ------------ | -------------------------------------- | ------ | -------------------------------------------------------------------- |
| reverse(first, last)                  | O(n)         | 区间范围 [first, last)                 | 无     | 反转指定范围内的元素                                                 |
|                                       |              |                                        |        |                                                                      |
| sort(first, last, [cmp])              | O(n log n)   | 区间范围 [first, last) 和 比较函数 cmp | 无     | 快速排序                                                             |
| stable_sort(first, last, [cmp])       | O(N*log2(N)) | 区间范围 [first, last) 和 比较函数 cmp | 无     | 归并排序                                                             |
| partial_sort(first,middle,last,[cmp]) | N*log(M)     |                                        |        | [first, last) 范围内的 middle-first 个元素移动到 [first, middle)排序 |
| nth_element(first,nth,last,[cmp])     | O(n)         | 区间范围 [first, last) 和 nth迭代器    | 无     | 令函数查找“第 nth 大”的元素，并将其移动到 nth 指向的位置             |
|                                       |              |                                        |        |                                                                      |
| find(first, last, value)              | O(n)         | 区间范围 [first, last) 和 值 value     | 迭代器 | 在指定范围内查找值为特定值的元素                                     |
| find_if(first, last, p)               | O(n)         | 区间范围 [first, last) 和 谓词 p       | 迭代器 | 在指定范围内查找满足特定条件的元素                                   |
| upper_bound(first, last, value)       | O(log n)     | 区间范围 [first, last) 和 值 value     | 迭代器 | 在已排序范围内查找第一个大于给定值的位置                             |
| lower_bound(first, last, value)       | O(log n)     | 区间范围 [first, last) 和 值 value     | 迭代器 | 在已排序范围内查找第一个不小于给定值的位置                           |
| fill(first, last, value)              | O(n)         | 区间范围 [first, last) 和 值 value     | 无     | 将指定范围内的元素用特定值填充                                       |
| binary_search(first, last, value)     | O(log n)     | 区间范围 [first, last) 和 值 value     | bool   | 在已排序范围内使用二分查找特定值                                     |
| count(first, last, value)             | O(n)         | 区间范围 [first, last) 和 值 value     | size_t | 统计指定范围内值为特定值的元素个数                                   |
| count_if(first, last, p)              | O(n)         | 区间范围 [first, last) 和 谓词 p       | size_t | 统计指定范围内满足特定条件的元素个数                                 |
| max_element(first, last, [cmp])       | O(n)         | 区间范围 [first, last) 和 比较函数 cmp | 迭代器 | 查找指定范围内的最大元素                                             |
| min_element(first, last, [cmp])       | O(n)         | 区间范围 [first, last) 和 比较函数 cmp | 迭代器 | 查找指定范围内的最小元素                                             |
| next_permutation(first, last)         | O(n)         | 区间范围 [first, last)                 | bool   | 计算指定范围内下一个排列                                             |
| prev_permutation(first, last)         | O(n)         | 区间范围 [first, last)                 | bool   | 计算指定范围内上一个排列                                             |
| unique(first,last)                    | O(n)         | 区间范围 [first, last)                 | 迭代器 | 移除相邻重复元素，并返回一个指向新范围末尾的迭代器                   |
|                                       |              |                                        |        |                                                                      |

==说明:==[]为可选参数

自定义函数返回值为`bool`类型

传入的两个参数 没有先后之分，只有大小关系的差异

- 若返回`true`，则表示`num1` 与`num2`应该交换顺序；
- 若返回`false`, 则`num1` 与`num2` 保持原有顺序；

返回true代表得到的结果  num1 在 num2 前面

```c++
// 基础
int a = 1, b = 2;
max(a,b);//求两个数最大值 
min(a,b);//求两个数最小值
abs(a);//abs(x)----返回绝对值,必须是整数(浮点数用math函数下的fabs())
swap(a,b);//交换a,b的值


vector<int> nums = { 3, 6, 2, 8, 4, 4 };
// 容器|数组 (容器传迭代器，数组传0,length) 区间:左闭右开 返回的指针或者迭代器用*可以获取值
reverse(nums.begin(),bums.end());//翻转数组 O(n)  可以部分翻转,数组传0,0+6
sort(起点,终点);//排序容器 平均O(nlogn) 默认升序 可自定义规则sort(a,a+5,cmp)，第三个参数传函数指针 bool cmp(int a, int b) {return a > b; }
find(起点,终点,value);//查找 找到返回地址(迭代器、指针),找不到返回n+1个值的地址
find_if(起点,终点,isOdd);//函数用于在容器中查找满足特定条件的第一个元素 第三个参数传函数指针 bool isOdd(int num) {return num % 2 != 0;} 
upper_bound(起点,终点,value);//查找第一个大于x的值的位置,用法同find
lower_bound(起点,终点,value)//查找第一个大于等于x的值的位置,用法同find
fill(起点,终点,value);//填充,在区间填充某一个值
binary_search(起点,终点,value);//二分查找,判断是否有这个数字;
count(起点,终点,value);//查找某值在某区间出现的次数
count_if(起点,终点,cmp)//计算满足特定条件的元素个数
unique(起点,终点)//将数组中相邻的重复元素去除
    
max_element(起点,终点,cmp);//----返回容器中最大值的位置(指针或迭代器); cmp为可选参数自定义谓词函数
min_element(起点,终点,cmp);//----返回容器中最小值的位置(指针或迭代器);

//函数将指定范围内的元素重新排列为下一个|上一个字典序排列。如果存在下一个排列，则函数返回true，并且该范围内的元素已经被重新排列；如果不存在下一个排列（即当前排列已经是最大的排列），则函数返回 false，并且范围内的元素保持不变。
next_permutation(起点,终点);//----范围内按字典升序进行全排序;
prev_permutation(起点,终点);//----范围内按字典升序进行全排序;
do {
    for (int i : nums) {
        cout << i << " ";
    }
    cout << endl;
} while (next_permutation(nums.begin(), nums.end()));

//求交集、并集、差集：set_intersection()、set_union()、set_difference()
set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), inserter(v3,v3.begin()));
//inserter(c,c.begin()）为插入迭代器此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
```

# 线段树

线段树是一种[二叉搜索树](https://baike.baidu.com/item/二叉搜索树/7077855?fromModule=lemma_inlink)，与[区间树](https://baike.baidu.com/item/区间树/5772433?fromModule=lemma_inlink)相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。
使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。

## 结构

```c++
struct node
{
	int l,r,w,f;//l，r分别表示区间左右端点，w表示区间和，f为懒标记
}tree[400001];//开4倍空间
```

## 建树

```c++
inline void build(int k,int ll,int rr)//建树  第k个结点区间范围是[ll,rr]
{
	tree[k].l=ll,tree[k].r=rr;
	if(tree[k].l==tree[k].r)
	{
		scanf("%d",&tree[k].w);
		return;
	}
	int m=(ll+rr)/2;
	build(k*2,ll,m);
	build(k*2+1,m+1,rr);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
```

## 标记下传

```c++
inline void down(int k)//标记下传 
{
	tree[k*2].f+=tree[k].f;
	tree[k*2+1].f+=tree[k].f;
	tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1);
	tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1);
	tree[k].f=0;
}
```

## 单点修改

```c++
inline void ask_point(int k)//单点查询
{
	if(tree[k].l==tree[k].r)
	{
		ans=tree[k].w;
		return ;
	}
	if(tree[k].f) down(k);
	int m=(tree[k].l+tree[k].r)/2;
	if(x<=m) ask_point(k*2);
	else ask_point(k*2+1);
}
```

## 区间查询

```c++
inline void ask_interval(int k)//区间查询 
{
	if(tree[k].l>=a&&tree[k].r<=b) 
	{
		ans+=tree[k].w;
		return;
	}
	if(tree[k].f) down(k);
	int m=(tree[k].l+tree[k].r)/2;
	if(a<=m) ask_interval(k*2);
	if(b>m) ask_interval(k*2+1);
}
```

## 区间修改

```c++
inline void change_interval(int k)//区间修改 
{
	if(tree[k].l>=a&&tree[k].r<=b)
	{
		tree[k].w+=(tree[k].r-tree[k].l+1)*y;
		tree[k].f+=y;
		return;
	}
	if(tree[k].f) down(k);
	int m=(tree[k].l+tree[k].r)/2;
	if(a<=m) change_interval(k*2);
	if(b>m) change_interval(k*2+1);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
```

# 博弈论入门

## 拿石头

```
你和你的朋友，两个人一起玩游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。你们是聪明人，每一步都是最优解。 编写一个程序，来判断你是否可以在给定石头数量的情况下赢得游戏。
```

示例:

输入: 4 输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

这个题目的典型特征：只有两个玩家，游戏规则固定，游戏里面有可变的数据（这题是石头的数量），询问你是否必胜？ 看到这种描述你就要明白，你遇到一个博弈论的题目啦，千万注意绝对不是让你用程序去模拟题目的游戏过程再得出结果的。你要在脑中分析出过程，**重点分析两点：1.什么时候可以判定胜利者，2.先手的影响。**

题目描述了石头数量为 4 的情况，数量为 4 的时候先手的那个人必输，因为他一次拿不完，但是又不得不拿，不管他拿多少后手的人只要把剩下的都拿完就赢了。这个时候发散思维就派上用场了，这个示例给我们的启示是：只要场上剩下的石头数量是 4 的倍数，那么后手必胜，假设这一轮先手的一方拿了a个，那么后手的一方就拿 4 - a 个，按照这样的玩法，每轮消耗4块石头。玩完最后一轮后手就赢了。 所以这个游戏==后手必胜规则是：当石头数量是 4 的倍数。==

因为后手输了就代表先手赢了，所以==先手必胜的条件是反着的：当石头数量不是 4 的倍数。==

到这里这个题目已经解出来了，如果你好奇石头数量不能被 4 整除时先手怎么赢的，那么可以看这里: 对于这个游戏来说，假设原本的游戏规则是共有 n 个石头，A 先手，B后手，如果 A 总是先手拿 m 个石头，那么这个游戏等同于共有 n - m 个石头，B 先手， A 后手的一场游戏。所以，当石头数量不能被 4 整除的时候，先手拿走被4整除的余数数量的石头就能保证必胜。

拿石头这个游戏是经典的“巴什博弈”。

# 动态规划

## 线性(最长上升子序列)

例:   1 2 7 8 4 9 6 3 5 2

一、求解过程(nlogn):  ==导弹拦截中:dp[i]表示拦截i个导弹后的最高导弹高度==  ==Dilworth定理：一个序列最少的最长不上升子序列数量等于其最长上升子序列的长度。==
依次更新dp数组,如果大于最后一个数，放到末尾，否则放到小于(根据题目看有无等)的最大数后面 ==(可以二分)==
1
1 2
1 2 7
1 2 7 8
1 2 4 8
2 4 8 9
1 2 4 6 9
1 2 3 6 9
1 2 3 5 9
2 3 5 9
能求序列
字符串拼接也能用这种方法，必须按照字典序排序。

二、双重for循环(n^2)，dp[i]表示前i个数的最长上升序列长度
dp[i]=max(dp[ki])==(前面所有小于当前数的dp最大值)==+1
只能求长度

## 背包问题

### 01背包

```
一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，求能够装入背包的最大价值是多少？
```

每件物品==只能拿一次==
$dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。$
两个限制(二维数组)、多个限制(多维数组)

> **动态规划解法**：
>
> 1. **定义状态：** 通常使用二维数组`dp[i][j]`表示在前`i`个物品中，背包容量为`j`时的最大总价值。
>
> 2. **状态转移方程：** 考虑第`i`个物品，可以选择放入背包或者不放入。如果选择放入，那么总价值为`dp[i][j-weight[i]] + value[i]`，即前`i`个物品的总价值加上当前物品的价值。如果选择不放入，那么总价值为`dp[i-1][j]`，即前`i-1`个物品的总价值。因此，状态转移方程为：
>
>    ```cpp
>    dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] + value[i])
>    ```
>
>    其中，`dp[i-1][j]`表示不放入第`i`个物品，`dp[i][j-weight[i]] + value[i]`表示放入第`i`个物品。
>
> 3. **初始条件：** 当`i=0`时，表示前0个物品，总价值为0；当`j=0`时，表示背包容量为0，总价值也为0。
>
> 4. **遍历顺序：** 外层循环遍历物品，内层循环遍历背包容量。
>
> 5. **返回结果：** 最终结果存储在`dp[N][W]`中，其中`N`为物品数量，`W`为背包容量。

eg: [NOIP2005 普及组] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1048)

```c++
//dp[i][j]以 j 为容量为放入前i个物品(按 i 从小到大的顺序)的最大价值
for(int i=1;i<=m;i++){
     for(int j=1;j<=t;j++){
	   if(j>=things[i].t){//如果当前容量大于需要放入物品的容量 决定要不要拿
         dp[i][j]=max(dp[i-1][j-things[i].t]+things[i].v,dp[i-1][j]);//最大价值为放入和不放入两者最大和
       }
       else dp[i][j]=dp[i-1][j];//放不进去最大价值就是放前i-1个的最大价值
     }
}
```

eg2:[P1855 榨取kkksc03 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1855)

```c++
//dp[i][j][k]以j为金钱限制,k为时间限制放入前i个物品的最大数量
for(int i=1;i<=n;i++){
     for(int j=1;j<=m;j++){
       for(int k=1;k<=t;k++){
		 if(j>=wishes[i].money&&k>=wishes[i].minute){   //如果钱够并且时间也够 决定要不要拿
           dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-wishes[i].money][k-wishes[i].minute]+1);
         }
         else dp[i][j][k]=dp[i-1][j][k]; //不拿的话时间金钱不变 价值等于拿前i-1的价值
       }
     }
}
```

### 完全背包

```
完全背包问题一般是指：有N件物品和一个能背重量为W的背包，第i件物品的重量为weight[i],价值为value[i]。**每件物品有无限个(也就是可以放入背包多次，求怎样可以使背包物品价值总量最大。
```

完全背包与01背包问题的区别在于01背包物品**只有一个**，完全背包有**无数个**。

# 并查集

洛谷p3367

```c++
int fa[100010];

int find(int x) {//查询操作
  if (x != fa[x])  
    fa[x] = find(fa[x]);  
  return fa[x];
}9
void unionSet(int x, int y) {//合并操作
  x = find(x);//其实不用刻意写函数，直接在主函数中写亦可
  y = find(y);
  if (x != y) fa[x] = y; 
}
void check(int x,int y){//判断是否在同一个集合
	if(find(x)==find(y)) cout << "Y" << endl;
	else cout << "N" << endl;
}
```

# 深度优先搜索dfs

```c++
//模版
void dfs(){
    //判断边界
    if(){
        ans++;
        return;
    }
    //剪枝
    if(){
        return;
	}
    //递归搜索
    for(int i=0;i<n;i++){
        /*
        	矩阵遍历;
        	枚举n个方向
        	dfs(x+dx[i],y+dy[i])
        */
        visited[]=true;
        /* if() */  dfs();
        visited[]=false;//回溯
    }
}
```

# 素数判断

## 素数判断方法

```c++
inline bool isPrime(int n){
	if(n<2) return false;
	for(int i=2;i<=n/i;i++){
		if(n%i==0) return false;
	}
	return true;
}
//不用sqrt，i*i会溢出
```

## 埃氏筛

一个合数，一定存在非1非本身的质因子

```c++
//筛选1-N之间的素数
const int N=1e6;
bool isPrime[N];//true代表是质数
void Erat_Prime(int n){
	memset(vis,1,sizeof(vis));
	isPrime[0]=isPrime[1]=false;	//0和1均不是素数
	for(int i=2;i*i<=n;i++){
		if(isPrime[i]){
			for(int j=i*i;j<=n;j+=i)
				isPrime[j]=false;
		}
	} 
}
//朴素筛就是 for(int i=2;i<=n;i++) for j=i*2;j<=n;j+=i...
```

## 欧拉筛

```c++
const int N=1e5+10;
int vis[N];	//0表示素数，1表示非素数
int prime[N];	//只在这个函数有作用
void Euler_prime()  //欧拉筛法
{
    for(int i=2;i<=N;i++)
    {
        if(!vis[i]) prime[x++]=i;
        for(int j=0;j<x;j++)
        {
            if(i*prime[j]>N) break;
            vis[i*prime[j]]=1;
            if(i%prime[j]==0) break;
        }
    }
}

```
